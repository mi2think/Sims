/********************************************************************
	created:	2016/11/07
	created:	7:11:2016   22:59
	filename: 	D:\Code\Sims\Sims\graphics_api\ogl\ogl_program.cpp
	file path:	D:\Code\Sims\Sims\graphics_api\ogl
	file base:	ogl_program
	file ext:	cpp
	author:		mi2think@gmail.com

	purpose:	OGL Program
*********************************************************************/
#include "ogl_program.h"
#include "ogl_shader.h"

namespace sims
{
	namespace ogl
	{
		OGLProgramResource::OGLProgramResource()
			: ProgramResource()
			, prog_(0)
		{
		}

		OGLProgramResource::~OGLProgramResource()
		{
			InternalReleaseResource();
		}

		void OGLProgramResource::UpdateResource() 
		{
			ReleaseResource();

			prog_ = glCreateProgram();
			for (int i = 0; i < ShaderDomain::Max; ++i)
			{
				auto type = ShaderDomain::Type(i);
				auto shader = program_->GetShader(type);
				if (! shader)
					continue;

				auto& shaderRes = shader->HWResource();
				if (shaderRes)
				{
					auto oglShaderRes = shaderRes.As<OGLShaderResource>();
					glAttachShader(prog_, oglShaderRes->GetResource());
				}
			}
		
			glLinkProgram(prog_);
			GLint status;
			glGetProgramiv(prog_, GL_LINK_STATUS, &status);
			if (status != GL_TRUE)
			{
				GLint logSize = 0;
				glGetProgramiv(prog_, GL_INFO_LOG_LENGTH, &logSize);
				if (logSize > 1)
				{
					string log;
					log.resize(logSize);
					glGetProgramInfoLog(prog_, logSize, nullptr, &log[0]);

					LOG_ERROR("Link Program error:");
					LOG_ERROR("%s", log.c_str());
				}
				glDeleteProgram(prog_);
				prog_ = 0;
				return;
			}

			glValidateProgram(prog_);
			glGetProgramiv(prog_, GL_VALIDATE_STATUS, &status);
			if (status != GL_TRUE)
			{
				GLint logSize = 0;
				glGetProgramiv(prog_, GL_INFO_LOG_LENGTH, &logSize);
				if (logSize > 1)
				{
					string log;
					log.resize(logSize);
					glGetProgramInfoLog(prog_, logSize, nullptr, &log[0]);

					LOG_ERROR("Validate Program error:");
					LOG_ERROR("%s", log.c_str());
				}
				glDeleteProgram(prog_);
				prog_ = 0;
			}
		}

		void OGLProgramResource::BindResource() const
		{
			ASSERT(prog_ != 0);
			glUseProgram(prog_);
		}

		void OGLProgramResource::ReleaseResource()
		{
			InternalReleaseResource();
		}

		void OGLProgramResource::InternalReleaseResource()
		{
			if (prog_)
			{
				glDeleteProgram(prog_);
				prog_ = 0;
			}
		}

		//UniformLoc OGLProgramResource::GetUniformLoc(const char* name) const
		//{
		//	GLuint loc = glGetUniformLocation(prog_, name);
		//	if (loc == GL_INVALID_VALUE)
		//		LOG_ERROR("Program is now value generated by OpenGL");
		//	else if (loc == GL_INVALID_OPERATION)
		//		LOG_ERROR("Program is not a program or link failed");
		//	return (UniformLoc)loc;
		//}

		//void OGLProgramResource::BindUniform(UniformLoc loc, const void* data, uint32 count, UniformDataType::Type type)
		//{
		//	GLint location = (GLint)loc;
		//	switch (type)
		//	{
		//	case UniformDataType::Int:
		//		glUniform1iv(location, count, (const GLint*)data);
		//		break;
		//	case UniformDataType::Int2:
		//		glUniform2iv(location, count, (const GLint*)data);
		//		break;
		//	case UniformDataType::Int3:
		//		glUniform3iv(location, count, (const GLint*)data);
		//		break;
		//	case UniformDataType::Int4:
		//		glUniform4iv(location, count, (const GLint*)data);
		//		break;
		//	case UniformDataType::F32:
		//		glUniform1fv(location, count, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Vec2:
		//		glUniform2fv(location, count, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Vec3:
		//		glUniform3fv(location, count, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Vec4:
		//		glUniform4fv(location, count, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Mat3:
		//		glUniformMatrix3fv(location, count, GL_FALSE, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Mat4:
		//		glUniformMatrix4fv(location, count, GL_FALSE, (const GLfloat*)data);
		//		break;
		//	case UniformDataType::Color:
		//		{
		//			ASSERT(count == 1);
		//			const Color& c = *(const Color*)data;
		//			auto v = c.GetRGBAVector4();
		//			glUniform4f(location, v.x, v.y, v.z, v.w);
		//		}
		//		break;
		//	case UniformDataType::Sampler2D:
		//	case UniformDataType::Unknown:
		//	default:
		//		ASSERT(false && "Unspported uniform type");
		//		break;
		//	}

		//	gl_check_error("OGLProgramResource::BindUniform");
		//}
	}
}